<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>My Org Tool</title>
    <style>
        /* 1. RESET & BASIC SETUP */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #1e1e1e;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            touch-action: none; /* Disables browser handling of gestures */
        }

        /* 2. BACKGROUND */
        .viewport {
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #2b2b2b 0%, #1a1a1a 100%);
            cursor: grab;
            position: relative;
            overflow: hidden;
        }

        .viewport:active {
            cursor: grabbing;
        }

        /* 3. THE WORLD CONTAINER */
        #world {
            position: absolute;
            top: 0;
            left: 0;
            width: 0;
            height: 0;
            transform-origin: 0 0;
            will-change: transform;
        }

        /* 4. ORIGIN MARKERS */
        .origin-circle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #ff5f56;
            border-radius: 50%;
            top: -10px;
            left: -10px;
            box-shadow: 0 0 15px rgba(255, 95, 86, 0.6);
            z-index: 10;
        }

        .grid-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.05);
            pointer-events: none;
        }
        
        .label {
            position: absolute;
            top: 15px;
            left: 15px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
        }

        .ui-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #666;
            font-size: 14px;
            pointer-events: none;
            user-select: none;
        }
    </style>
</head>
<body>

    <div class="viewport" id="viewport">
        <div id="world">
            <div class="origin-circle"></div>
            <div class="label">Origin (0, 0)</div>
            <div class="grid-line" style="width: 2000px; height: 1px; top: 0; left: -1000px;"></div>
            <div class="grid-line" style="width: 1px; height: 2000px; top: -1000px; left: 0;"></div>
        </div>

        <div class="ui-hint">
            Desktop: Scroll & Drag <br>
            Mobile: Pinch & Drag
        </div>
    </div>

    <script>
        const viewport = document.getElementById('viewport');
        const world = document.getElementById('world');

        // --- STATE VARIABLES ---
        let scale = 1;
        let pointX = window.innerWidth / 2;
        let pointY = window.innerHeight / 2;
        
        // Mouse State
        let isPanning = false;
        let startX = 0, startY = 0;

        // Touch State
        let lastTouchDistance = 0;
        let lastCenter = { x: 0, y: 0 }; // We now track the center point specifically

        // Apply initial position
        updateTransform();

        // ============================
        //     MOUSE EVENTS (DESKTOP)
        // ============================

        viewport.addEventListener('mousedown', (e) => {
            e.preventDefault();
            isPanning = true;
            startX = e.clientX - pointX;
            startY = e.clientY - pointY;
        });

        viewport.addEventListener('mousemove', (e) => {
            if (!isPanning) return;
            e.preventDefault();
            pointX = e.clientX - startX;
            pointY = e.clientY - startY;
            updateTransform();
        });

        viewport.addEventListener('mouseup', () => isPanning = false);
        viewport.addEventListener('mouseleave', () => isPanning = false);

        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();
            const xs = (e.clientX - pointX) / scale;
            const ys = (e.clientY - pointY) / scale;
            const delta = -e.deltaY;

            let newScale = scale;
            (delta > 0) ? (newScale *= 1.1) : (newScale /= 1.1);
            
            // Apply constraints immediately
            if (newScale < 0.1) newScale = 0.1;
            if (newScale > 50) newScale = 50;

            pointX = e.clientX - xs * newScale;
            pointY = e.clientY - ys * newScale;
            scale = newScale;

            updateTransform();
        }, { passive: false });


        // ============================
        //      TOUCH EVENTS (MOBILE)
        // ============================

        viewport.addEventListener('touchstart', (e) => {
            if (e.touches.length === 1) {
                // 1 Finger: Simple Pan Setup
                isPanning = true;
                startX = e.touches[0].clientX - pointX;
                startY = e.touches[0].clientY - pointY;
            } else if (e.touches.length === 2) {
                // 2 Fingers: Pinch & Pan Setup
                isPanning = false;
                lastTouchDistance = getDistance(e.touches);
                lastCenter = getCenter(e.touches); // Store where the center started
            }
        }, { passive: false });

        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();

            if (e.touches.length === 1 && isPanning) {
                // --- 1. SIMPLE PAN ---
                pointX = e.touches[0].clientX - startX;
                pointY = e.touches[0].clientY - startY;
                updateTransform();

            } else if (e.touches.length === 2) {
                // --- 2. PINCH + PAN ---
                
                // A. Calculate new distance and center
                const currentDistance = getDistance(e.touches);
                const currentCenter = getCenter(e.touches);

                // B. Calculate scale change
                const distanceRatio = currentDistance / lastTouchDistance;
                let newScale = scale * distanceRatio;

                // Clamp scale limits
                if (newScale < 0.1) newScale = 0.1;
                if (newScale > 50) newScale = 50;

                // C. THE MAGIC MATH:
                // We calculate where the center point WAS in the "world" coordinates
                // before this frame's movement.
                const worldX = (lastCenter.x - pointX) / scale;
                const worldY = (lastCenter.y - pointY) / scale;

                // D. Apply the new scale
                scale = newScale;

                // E. Move (Pan) the world so that the "world point" we found in step C
                // sits exactly under the NEW center finger position.
                pointX = currentCenter.x - worldX * scale;
                pointY = currentCenter.y - worldY * scale;

                // F. Update state for next frame
                lastTouchDistance = currentDistance;
                lastCenter = currentCenter;
                
                updateTransform();
            }
        }, { passive: false });

        viewport.addEventListener('touchend', (e) => {
            // Smoothly switch back to 1-finger pan if 1 finger remains
            if (e.touches.length === 1) {
                isPanning = true;
                startX = e.touches[0].clientX - pointX;
                startY = e.touches[0].clientY - pointY;
            }
        });


        // ============================
        //        HELPER FUNCTIONS
        // ============================

        function updateTransform() {
            world.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
        }

        function getDistance(touches) {
            const dx = touches[0].clientX - touches[1].clientX;
            const dy = touches[0].clientY - touches[1].clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        function getCenter(touches) {
            return {
                x: (touches[0].clientX + touches[1].clientX) / 2,
                y: (touches[0].clientY + touches[1].clientY) / 2
            };
        }
    </script>
</body>
</html>
