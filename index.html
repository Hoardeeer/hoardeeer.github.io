<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Org Tool</title>
    <style>
        /* 1. RESET & BASIC SETUP */
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Prevent native scrollbars */
            background: #1e1e1e; /* Fallback color */
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        /* 2. PROFESSIONAL DARK BACKGROUND */
        /* Using a subtle gradient to look modern and deep */
        .viewport {
            width: 100vw;
            height: 100vh;
            background: radial-gradient(circle at center, #2b2b2b 0%, #1a1a1a 100%);
            cursor: grab; /* Indicates the area is pannable */
            position: relative;
        }

        .viewport:active {
            cursor: grabbing; /* Visual feedback when dragging */
        }

        /* 3. THE "WORLD" CONTAINER 
           This is the element we will actually move and zoom. 
        */
        #world {
            position: absolute;
            top: 0;
            left: 0;
            width: 0; /* width/height 0 effectively makes (0,0) the origin */
            height: 0;
            transform-origin: 0 0; /* Zoom relative to the top-left origin coordinates we calculate */
        }

        /* 4. THE ORIGIN CIRCLE (0,0) */
        .origin-circle {
            position: absolute;
            width: 20px;
            height: 20px;
            background-color: #ff5f56; /* A nice distinct coral/red */
            border-radius: 50%;
            /* Center the circle exactly on (0,0) */
            top: -10px;
            left: -10px;
            box-shadow: 0 0 10px rgba(255, 95, 86, 0.6);
            z-index: 10;
        }

        /* Optional: A grid to make movement easier to see */
        .grid-line {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.05);
            pointer-events: none;
        }
        
        /* Simple label for the origin */
        .label {
            position: absolute;
            top: 15px;
            left: 15px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            pointer-events: none;
            white-space: nowrap;
        }
    </style>
</head>
<body>

    <div class="viewport" id="viewport">
        
        <div id="world">
            
            <div class="origin-circle"></div>
            <div class="label">Origin (0, 0)</div>

            <div class="grid-line" style="width: 2000px; height: 1px; top: 0; left: -1000px;"></div>
            <div class="grid-line" style="width: 1px; height: 2000px; top: -1000px; left: 0;"></div>

        </div>

        <div style="position: fixed; bottom: 20px; left: 20px; color: #666; font-size: 14px; pointer-events: none;">
            Scroll to Zoom â€¢ Click & Drag to Pan
        </div>
    </div>

    <script>
        const viewport = document.getElementById('viewport');
        const world = document.getElementById('world');

        // State variables
        let scale = 1;
        let panning = false;
        let pointX = window.innerWidth / 2; // Start centered
        let pointY = window.innerHeight / 2;
        let startX = 0;
        let startY = 0;

        // Apply the initial transform
        setTransform();

        // 1. ZOOM (Wheel Event)
        viewport.addEventListener('wheel', (e) => {
            e.preventDefault();

            const xs = (e.clientX - pointX) / scale;
            const ys = (e.clientY - pointY) / scale;

            const delta = -e.deltaY;
            
            // Limit zoom speed and range
            const factor = 1.1;
            if (delta > 0) {
                scale *= factor;
            } else {
                scale /= factor;
            }

            // Cap the zoom levels (optional)
            // if (scale > 10) scale = 10;
            // if (scale < 0.1) scale = 0.1;

            pointX = e.clientX - xs * scale;
            pointY = e.clientY - ys * scale;

            setTransform();
        }, { passive: false });

        // 2. PANNING (Mouse Events)
        viewport.addEventListener('mousedown', (e) => {
            e.preventDefault();
            startX = e.clientX - pointX;
            startY = e.clientY - pointY;
            panning = true;
        });

        viewport.addEventListener('mouseup', () => {
            panning = false;
        });

        viewport.addEventListener('mouseleave', () => {
            panning = false;
        });

        viewport.addEventListener('mousemove', (e) => {
            e.preventDefault();
            if (!panning) return;
            
            pointX = e.clientX - startX;
            pointY = e.clientY - startY;
            
            setTransform();
        });

        // 3. TOUCH SUPPORT (Mobile/Tablet)
        let lastTouchDistance = 0;
        let initialPinchScale = 1;

        viewport.addEventListener('touchstart', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1) {
                // Single touch - panning
                startX = e.touches[0].clientX - pointX;
                startY = e.touches[0].clientY - pointY;
                panning = true;
            } else if (e.touches.length === 2) {
                // Two finger touch - prepare for pinch zoom
                panning = false;
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                lastTouchDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                initialPinchScale = scale;
            }
        }, { passive: false });

        viewport.addEventListener('touchmove', (e) => {
            e.preventDefault();
            
            if (e.touches.length === 1 && panning) {
                // Single touch - pan
                pointX = e.touches[0].clientX - startX;
                pointY = e.touches[0].clientY - startY;
                setTransform();
            } else if (e.touches.length === 2) {
                // Two finger pinch zoom
                const touch1 = e.touches[0];
                const touch2 = e.touches[1];
                
                // Calculate center point between fingers
                const centerX = (touch1.clientX + touch2.clientX) / 2;
                const centerY = (touch1.clientY + touch2.clientY) / 2;
                
                // Calculate current distance between fingers
                const currentDistance = Math.hypot(
                    touch2.clientX - touch1.clientX,
                    touch2.clientY - touch1.clientY
                );
                
                // Calculate zoom point in world coordinates
                const xs = (centerX - pointX) / scale;
                const ys = (centerY - pointY) / scale;
                
                // Update scale based on pinch distance change
                scale = initialPinchScale * (currentDistance / lastTouchDistance);
                
                // Update position to keep zoom centered on pinch point
                pointX = centerX - xs * scale;
                pointY = centerY - ys * scale;
                
                setTransform();
            }
        }, { passive: false });

        viewport.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
                panning = false;
            } else if (e.touches.length === 1) {
                // Transition from pinch to pan
                startX = e.touches[0].clientX - pointX;
                startY = e.touches[0].clientY - pointY;
                panning = true;
            }
        });

        viewport.addEventListener('touchcancel', () => {
            panning = false;
        });

        // Helper function to apply CSS
        function setTransform() {
            world.style.transform = `translate(${pointX}px, ${pointY}px) scale(${scale})`;
        }
    </script>
</body>
</html>
